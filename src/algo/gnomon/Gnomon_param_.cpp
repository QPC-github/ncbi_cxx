/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * File Description:
 *   This code was generated by application DATATOOL
 *   using the following specifications:
 *   'gnomon.asn'.
 *
 * ATTENTION:
 *   Don't edit or commit this file into CVS as this file will
 *   be overridden (by DATATOOL) without warning!
 * ===========================================================================
 */

// standard includes
#include <ncbi_pch.hpp>
#include <serial/serialimpl.hpp>

// generated includes
#include <algo/gnomon/Gnomon_param.hpp>
#include <algo/gnomon/Exon_params.hpp>
#include <algo/gnomon/Intergenic_params.hpp>
#include <algo/gnomon/Intron_params.hpp>
#include <algo/gnomon/Markov_chain_array.hpp>
#include <algo/gnomon/Markov_chain_params.hpp>
BEGIN_NCBI_SCOPE

BEGIN_objects_SCOPE // namespace ncbi::objects::


// generated classes

void CGnomon_param_Base::C_Gc_content_range::Reset(void)
{
    ResetFrom();
    ResetTo();
}

BEGIN_NAMED_CLASS_INFO("", CGnomon_param_Base::C_Gc_content_range)
{
    SET_INTERNAL_NAME("Gnomon-param", "gc-content-range");
    SET_CLASS_MODULE("NCBI-GNOMON");
    ADD_NAMED_STD_MEMBER("from", m_From)->SetSetFlag(MEMBER_PTR(m_set_State[0]));
    ADD_NAMED_STD_MEMBER("to", m_To)->SetSetFlag(MEMBER_PTR(m_set_State[0]));
    info->RandomOrder();
}
END_CLASS_INFO

// constructor
CGnomon_param_Base::C_Gc_content_range::C_Gc_content_range(void)
    : m_From(0), m_To(0)
{
    memset(m_set_State,0,sizeof(m_set_State));
}

// destructor
CGnomon_param_Base::C_Gc_content_range::~C_Gc_content_range(void)
{
}


void CGnomon_param_Base::C_Param::Reset(void)
{
    if ( m_choice != e_not_set )
        ResetSelection();
}

void CGnomon_param_Base::C_Param::ResetSelection(void)
{
    switch ( m_choice ) {
    case e_Coding_region:
        m_Coding_region.Destruct();
        break;
    case e_Intergenic:
    case e_Intron:
    case e_Exon:
    case e_Start:
    case e_Stop:
    case e_Donor:
    case e_Acceptor:
    case e_Non_coding_region:
        m_object->RemoveReference();
        break;
    default:
        break;
    }
    m_choice = e_not_set;
}

void CGnomon_param_Base::C_Param::DoSelect(E_Choice index, NCBI_NS_NCBI::CObjectMemoryPool* pool)
{
    switch ( index ) {
    case e_Intergenic:
        (m_object = new(pool) ncbi::objects::CIntergenic_params())->AddReference();
        break;
    case e_Intron:
        (m_object = new(pool) ncbi::objects::CIntron_params())->AddReference();
        break;
    case e_Exon:
        (m_object = new(pool) ncbi::objects::CExon_params())->AddReference();
        break;
    case e_Start:
        (m_object = new(pool) ncbi::objects::CMarkov_chain_array())->AddReference();
        break;
    case e_Stop:
        (m_object = new(pool) ncbi::objects::CMarkov_chain_array())->AddReference();
        break;
    case e_Donor:
        (m_object = new(pool) ncbi::objects::CMarkov_chain_array())->AddReference();
        break;
    case e_Acceptor:
        (m_object = new(pool) ncbi::objects::CMarkov_chain_array())->AddReference();
        break;
    case e_Coding_region:
        m_Coding_region.Construct();
        break;
    case e_Non_coding_region:
        (m_object = new(pool) ncbi::objects::CMarkov_chain_params())->AddReference();
        break;
    default:
        break;
    }
    m_choice = index;
}

const char* const CGnomon_param_Base::C_Param::sm_SelectionNames[] = {
    "not set",
    "intergenic",
    "intron",
    "exon",
    "start",
    "stop",
    "donor",
    "acceptor",
    "coding-region",
    "non-coding-region"
};

NCBI_NS_STD::string CGnomon_param_Base::C_Param::SelectionName(E_Choice index)
{
    return NCBI_NS_NCBI::CInvalidChoiceSelection::GetName(index, sm_SelectionNames, sizeof(sm_SelectionNames)/sizeof(sm_SelectionNames[0]));
}

void CGnomon_param_Base::C_Param::ThrowInvalidSelection(E_Choice index) const
{
    throw NCBI_NS_NCBI::CInvalidChoiceSelection(DIAG_COMPILE_INFO, this, m_choice, index, sm_SelectionNames, sizeof(sm_SelectionNames)/sizeof(sm_SelectionNames[0]));
}

const CGnomon_param_Base::C_Param::TIntergenic& CGnomon_param_Base::C_Param::GetIntergenic(void) const
{
    CheckSelected(e_Intergenic);
    return *static_cast<const TIntergenic*>(m_object);
}

CGnomon_param_Base::C_Param::TIntergenic& CGnomon_param_Base::C_Param::SetIntergenic(void)
{
    Select(e_Intergenic, NCBI_NS_NCBI::eDoNotResetVariant);
    return *static_cast<TIntergenic*>(m_object);
}

void CGnomon_param_Base::C_Param::SetIntergenic(CGnomon_param_Base::C_Param::TIntergenic& value)
{
    TIntergenic* ptr = &value;
    if ( m_choice != e_Intergenic || m_object != ptr ) {
        ResetSelection();
        (m_object = ptr)->AddReference();
        m_choice = e_Intergenic;
    }
}

const CGnomon_param_Base::C_Param::TIntron& CGnomon_param_Base::C_Param::GetIntron(void) const
{
    CheckSelected(e_Intron);
    return *static_cast<const TIntron*>(m_object);
}

CGnomon_param_Base::C_Param::TIntron& CGnomon_param_Base::C_Param::SetIntron(void)
{
    Select(e_Intron, NCBI_NS_NCBI::eDoNotResetVariant);
    return *static_cast<TIntron*>(m_object);
}

void CGnomon_param_Base::C_Param::SetIntron(CGnomon_param_Base::C_Param::TIntron& value)
{
    TIntron* ptr = &value;
    if ( m_choice != e_Intron || m_object != ptr ) {
        ResetSelection();
        (m_object = ptr)->AddReference();
        m_choice = e_Intron;
    }
}

const CGnomon_param_Base::C_Param::TExon& CGnomon_param_Base::C_Param::GetExon(void) const
{
    CheckSelected(e_Exon);
    return *static_cast<const TExon*>(m_object);
}

CGnomon_param_Base::C_Param::TExon& CGnomon_param_Base::C_Param::SetExon(void)
{
    Select(e_Exon, NCBI_NS_NCBI::eDoNotResetVariant);
    return *static_cast<TExon*>(m_object);
}

void CGnomon_param_Base::C_Param::SetExon(CGnomon_param_Base::C_Param::TExon& value)
{
    TExon* ptr = &value;
    if ( m_choice != e_Exon || m_object != ptr ) {
        ResetSelection();
        (m_object = ptr)->AddReference();
        m_choice = e_Exon;
    }
}

const CGnomon_param_Base::C_Param::TStart& CGnomon_param_Base::C_Param::GetStart(void) const
{
    CheckSelected(e_Start);
    return *static_cast<const TStart*>(m_object);
}

CGnomon_param_Base::C_Param::TStart& CGnomon_param_Base::C_Param::SetStart(void)
{
    Select(e_Start, NCBI_NS_NCBI::eDoNotResetVariant);
    return *static_cast<TStart*>(m_object);
}

void CGnomon_param_Base::C_Param::SetStart(CGnomon_param_Base::C_Param::TStart& value)
{
    TStart* ptr = &value;
    if ( m_choice != e_Start || m_object != ptr ) {
        ResetSelection();
        (m_object = ptr)->AddReference();
        m_choice = e_Start;
    }
}

const CGnomon_param_Base::C_Param::TStop& CGnomon_param_Base::C_Param::GetStop(void) const
{
    CheckSelected(e_Stop);
    return *static_cast<const TStop*>(m_object);
}

CGnomon_param_Base::C_Param::TStop& CGnomon_param_Base::C_Param::SetStop(void)
{
    Select(e_Stop, NCBI_NS_NCBI::eDoNotResetVariant);
    return *static_cast<TStop*>(m_object);
}

void CGnomon_param_Base::C_Param::SetStop(CGnomon_param_Base::C_Param::TStop& value)
{
    TStop* ptr = &value;
    if ( m_choice != e_Stop || m_object != ptr ) {
        ResetSelection();
        (m_object = ptr)->AddReference();
        m_choice = e_Stop;
    }
}

const CGnomon_param_Base::C_Param::TDonor& CGnomon_param_Base::C_Param::GetDonor(void) const
{
    CheckSelected(e_Donor);
    return *static_cast<const TDonor*>(m_object);
}

CGnomon_param_Base::C_Param::TDonor& CGnomon_param_Base::C_Param::SetDonor(void)
{
    Select(e_Donor, NCBI_NS_NCBI::eDoNotResetVariant);
    return *static_cast<TDonor*>(m_object);
}

void CGnomon_param_Base::C_Param::SetDonor(CGnomon_param_Base::C_Param::TDonor& value)
{
    TDonor* ptr = &value;
    if ( m_choice != e_Donor || m_object != ptr ) {
        ResetSelection();
        (m_object = ptr)->AddReference();
        m_choice = e_Donor;
    }
}

const CGnomon_param_Base::C_Param::TAcceptor& CGnomon_param_Base::C_Param::GetAcceptor(void) const
{
    CheckSelected(e_Acceptor);
    return *static_cast<const TAcceptor*>(m_object);
}

CGnomon_param_Base::C_Param::TAcceptor& CGnomon_param_Base::C_Param::SetAcceptor(void)
{
    Select(e_Acceptor, NCBI_NS_NCBI::eDoNotResetVariant);
    return *static_cast<TAcceptor*>(m_object);
}

void CGnomon_param_Base::C_Param::SetAcceptor(CGnomon_param_Base::C_Param::TAcceptor& value)
{
    TAcceptor* ptr = &value;
    if ( m_choice != e_Acceptor || m_object != ptr ) {
        ResetSelection();
        (m_object = ptr)->AddReference();
        m_choice = e_Acceptor;
    }
}

const CGnomon_param_Base::C_Param::TNon_coding_region& CGnomon_param_Base::C_Param::GetNon_coding_region(void) const
{
    CheckSelected(e_Non_coding_region);
    return *static_cast<const TNon_coding_region*>(m_object);
}

CGnomon_param_Base::C_Param::TNon_coding_region& CGnomon_param_Base::C_Param::SetNon_coding_region(void)
{
    Select(e_Non_coding_region, NCBI_NS_NCBI::eDoNotResetVariant);
    return *static_cast<TNon_coding_region*>(m_object);
}

void CGnomon_param_Base::C_Param::SetNon_coding_region(CGnomon_param_Base::C_Param::TNon_coding_region& value)
{
    TNon_coding_region* ptr = &value;
    if ( m_choice != e_Non_coding_region || m_object != ptr ) {
        ResetSelection();
        (m_object = ptr)->AddReference();
        m_choice = e_Non_coding_region;
    }
}

// helper methods

// type info
BEGIN_NAMED_CHOICE_INFO("", CGnomon_param_Base::C_Param)
{
    SET_INTERNAL_NAME("Gnomon-param", "param");
    SET_CHOICE_MODULE("NCBI-GNOMON");
    ADD_NAMED_REF_CHOICE_VARIANT("intergenic", m_object, CIntergenic_params);
    ADD_NAMED_REF_CHOICE_VARIANT("intron", m_object, CIntron_params);
    ADD_NAMED_REF_CHOICE_VARIANT("exon", m_object, CExon_params);
    ADD_NAMED_REF_CHOICE_VARIANT("start", m_object, CMarkov_chain_array);
    ADD_NAMED_REF_CHOICE_VARIANT("stop", m_object, CMarkov_chain_array);
    ADD_NAMED_REF_CHOICE_VARIANT("donor", m_object, CMarkov_chain_array);
    ADD_NAMED_REF_CHOICE_VARIANT("acceptor", m_object, CMarkov_chain_array);
    ADD_NAMED_BUF_CHOICE_VARIANT("coding-region", m_Coding_region, STL_list, (STL_CRef, (CLASS, (CMarkov_chain_params))));
    ADD_NAMED_REF_CHOICE_VARIANT("non-coding-region", m_object, CMarkov_chain_params);
}
END_CHOICE_INFO

// constructor
CGnomon_param_Base::C_Param::C_Param(void)
    : m_choice(e_not_set)
{
}

// destructor
CGnomon_param_Base::C_Param::~C_Param(void)
{
    Reset();
}


void CGnomon_param_Base::ResetGc_content_range(void)
{
    if ( !m_Gc_content_range ) {
        m_Gc_content_range.Reset(new TGc_content_range());
        return;
    }
    (*m_Gc_content_range).Reset();
}

void CGnomon_param_Base::SetGc_content_range(CGnomon_param_Base::TGc_content_range& value)
{
    m_Gc_content_range.Reset(&value);
}

void CGnomon_param_Base::ResetParam(void)
{
    if ( !m_Param ) {
        m_Param.Reset(new TParam());
        return;
    }
    (*m_Param).Reset();
}

void CGnomon_param_Base::SetParam(CGnomon_param_Base::TParam& value)
{
    m_Param.Reset(&value);
}

void CGnomon_param_Base::Reset(void)
{
    ResetGc_content_range();
    ResetParam();
}

BEGIN_NAMED_BASE_CLASS_INFO("Gnomon-param", CGnomon_param)
{
    SET_CLASS_MODULE("NCBI-GNOMON");
    ADD_NAMED_REF_MEMBER("gc-content-range", m_Gc_content_range, C_Gc_content_range);
    ADD_NAMED_REF_MEMBER("param", m_Param, C_Param);
    info->RandomOrder();
}
END_CLASS_INFO

// constructor
CGnomon_param_Base::CGnomon_param_Base(void)
{
    memset(m_set_State,0,sizeof(m_set_State));
    if ( !IsAllocatedInPool() ) {
        ResetGc_content_range();
        ResetParam();
    }
}

// destructor
CGnomon_param_Base::~CGnomon_param_Base(void)
{
}



END_objects_SCOPE // namespace ncbi::objects::

END_NCBI_SCOPE

