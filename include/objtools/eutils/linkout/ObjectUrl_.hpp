/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 */

/// @file ObjectUrl_.hpp
/// Data storage class.
///
/// This file was generated by application DATATOOL
/// using the following specifications:
/// 'linkout.dtd'.
///
/// ATTENTION:
///   Don't edit or commit this file into CVS as this file will
///   be overridden (by DATATOOL) without warning!

#ifndef linkout__OBJTOOLS_EUTILS_LINKOUT_OBJECTURL_BASE_HPP
#define linkout__OBJTOOLS_EUTILS_LINKOUT_OBJECTURL_BASE_HPP

// standard includes
#include <serial/serialbase.hpp>

// generated includes
#include <list>
#include <string>

#ifndef BEGIN_linkout_SCOPE
#  define BEGIN_linkout_SCOPE BEGIN_SCOPE(linkout)
#  define END_linkout_SCOPE END_SCOPE(linkout)
#endif
BEGIN_linkout_SCOPE // namespace linkout::


// forward declarations
class CRule;
class CRuleToMany;


// generated classes

/////////////////////////////////////////////////////////////////////////////
class NCBI_EUTILS_EXPORT CObjectUrl_Base : public NCBI_NS_NCBI::CSerialObject
{
    typedef NCBI_NS_NCBI::CSerialObject Tparent;
public:
    // constructor
    CObjectUrl_Base(void);
    // destructor
    virtual ~CObjectUrl_Base(void);

    // type info
    DECLARE_INTERNAL_TYPE_INFO();

    /////////////////////////////////////////////////////////////////////////////
    class NCBI_EUTILS_EXPORT C_Attlist : public NCBI_NS_NCBI::CSerialObject
    {
        typedef NCBI_NS_NCBI::CSerialObject Tparent;
    public:
        // constructor
        C_Attlist(void);
        // destructor
        ~C_Attlist(void);
    
        // type info
        DECLARE_INTERNAL_TYPE_INFO();
    
        enum EAttlist_LNG {
            eAttlist_LNG_DA =  1,
            eAttlist_LNG_DE =  2,
            eAttlist_LNG_EN =  3,
            eAttlist_LNG_EL =  4,
            eAttlist_LNG_ES =  5,
            eAttlist_LNG_FR =  6,
            eAttlist_LNG_IT =  7,
            eAttlist_LNG_IW =  8,
            eAttlist_LNG_JA =  9,
            eAttlist_LNG_NL = 10,
            eAttlist_LNG_NO = 11,
            eAttlist_LNG_RU = 12,
            eAttlist_LNG_SV = 13,
            eAttlist_LNG_ZH = 14
        };
        
        /// Access to EAttlist_LNG's attributes (values, names) as defined in spec
        static const NCBI_NS_NCBI::CEnumeratedTypeValues* ENUM_METHOD_NAME(EAttlist_LNG)(void);
        
        // types
        typedef EAttlist_LNG TLNG;
    
        // getters
        // setters
    
        /// optional with default eAttlist_LNG_EN
        /// typedef EAttlist_LNG TLNG
        ///  Check whether the LNG data member has been assigned a value.
        bool IsSetLNG(void) const;
        /// Check whether it is safe or not to call GetLNG method.
        bool CanGetLNG(void) const;
        void ResetLNG(void);
        void SetDefaultLNG(void);
        TLNG GetLNG(void) const;
        void SetLNG(TLNG value);
        TLNG& SetLNG(void);
    
        /// Reset the whole object
        void Reset(void);
    
    
    private:
        // Prohibit copy constructor and assignment operator
        C_Attlist(const C_Attlist&);
        C_Attlist& operator=(const C_Attlist&);
    
        // data
        Uint4 m_set_State[1];
        EAttlist_LNG m_LNG;
    };
    /////////////////////////////////////////////////////////////////////////////
    class NCBI_EUTILS_EXPORT C_Data : public NCBI_NS_NCBI::CSerialObject
    {
        typedef NCBI_NS_NCBI::CSerialObject Tparent;
    public:
        // constructor
        C_Data(void);
        // destructor
        ~C_Data(void);
    
        // type info
        DECLARE_INTERNAL_TYPE_INFO();
    
        /////////////////////////////////////////////////////////////////////////////
        class NCBI_EUTILS_EXPORT C_BaseData : public NCBI_NS_NCBI::CSerialObject
        {
            typedef NCBI_NS_NCBI::CSerialObject Tparent;
        public:
            // constructor
            C_BaseData(void);
            // destructor
            ~C_BaseData(void);
        
            // type info
            DECLARE_INTERNAL_TYPE_INFO();
        
            /////////////////////////////////////////////////////////////////////////////
            /// End of SubObjectSelector group 
            class NCBI_EUTILS_EXPORT C_Rule : public NCBI_NS_NCBI::CSerialObject
            {
                typedef NCBI_NS_NCBI::CSerialObject Tparent;
            public:
                // constructor
                C_Rule(void);
                // destructor
                ~C_Rule(void);
            
                // type info
                DECLARE_INTERNAL_TYPE_INFO();
            
            
                /// Choice variants.
                enum E_Choice {
                    e_not_set = 0,  ///< No variant selected
                    e_Rule,
                    e_RuleToMany
                };
                /// Maximum+1 value of the choice variant enumerator.
                enum E_ChoiceStopper {
                    e_MaxChoice = 3 ///< == e_RuleToMany+1
                };
            
                /// Reset the whole object
                void Reset(void);
            
                /// Reset the selection (set it to e_not_set).
                void ResetSelection(void);
            
                /// Which variant is currently selected.
                E_Choice Which(void) const;
            
                /// Verify selection, throw exception if it differs from the expected.
                void CheckSelected(E_Choice index) const;
            
                /// Throw 'InvalidSelection' exception.
                NCBI_NORETURN void ThrowInvalidSelection(E_Choice index) const;
            
                /// Retrieve selection name (for diagnostic purposes).
                static NCBI_NS_STD::string SelectionName(E_Choice index);
            
                /// Select the requested variant if needed.
                void Select(E_Choice index, NCBI_NS_NCBI::EResetVariant reset = NCBI_NS_NCBI::eDoResetVariant);
                /// Select the requested variant if needed,
                /// allocating CObject variants from memory pool.
                void Select(E_Choice index,
                            NCBI_NS_NCBI::EResetVariant reset,
                            NCBI_NS_NCBI::CObjectMemoryPool* pool);
            
                // types
                typedef CRule TRule;
                typedef CRuleToMany TRuleToMany;
            
                // getters
                // setters
            
                // typedef CRule TRule
                bool IsRule(void) const;
                const TRule& GetRule(void) const;
                TRule& SetRule(void);
                void SetRule(TRule& value);
            
                // typedef CRuleToMany TRuleToMany
                bool IsRuleToMany(void) const;
                const TRuleToMany& GetRuleToMany(void) const;
                TRuleToMany& SetRuleToMany(void);
                void SetRuleToMany(TRuleToMany& value);
            
            
            private:
                // copy constructor and assignment operator
                C_Rule(const C_Rule& );
                C_Rule& operator=(const C_Rule& );
                // choice state
                E_Choice m_choice;
                // helper methods
                void DoSelect(E_Choice index, NCBI_NS_NCBI::CObjectMemoryPool* pool = 0);
            
                static const char* const sm_SelectionNames[];
                // data
                NCBI_NS_NCBI::CSerialObject *m_object;
            };
            // types
            typedef NCBI_NS_STD::string TBase;
            typedef C_Rule TRule;
        
            // getters
            // setters
        
            /// mandatory
            /// typedef NCBI_NS_STD::string TBase
            ///  Check whether the Base data member has been assigned a value.
            bool IsSetBase(void) const;
            /// Check whether it is safe or not to call GetBase method.
            bool CanGetBase(void) const;
            void ResetBase(void);
            const TBase& GetBase(void) const;
            void SetBase(const TBase& value);
            TBase& SetBase(void);
        
            /// End of SubObjectSelector group 
            /// optional
            /// typedef C_Rule TRule
            ///  Check whether the Rule data member has been assigned a value.
            bool IsSetRule(void) const;
            /// Check whether it is safe or not to call GetRule method.
            bool CanGetRule(void) const;
            void ResetRule(void);
            const TRule& GetRule(void) const;
            void SetRule(TRule& value);
            TRule& SetRule(void);
        
            /// Reset the whole object
            void Reset(void);
        
        
        private:
            // Prohibit copy constructor and assignment operator
            C_BaseData(const C_BaseData&);
            C_BaseData& operator=(const C_BaseData&);
        
            // data
            Uint4 m_set_State[1];
            NCBI_NS_STD::string m_Base;
            NCBI_NS_NCBI::CRef< TRule > m_Rule;
        };
        /////////////////////////////////////////////////////////////////////////////
        class NCBI_EUTILS_EXPORT C_Rule : public NCBI_NS_NCBI::CSerialObject
        {
            typedef NCBI_NS_NCBI::CSerialObject Tparent;
        public:
            // constructor
            C_Rule(void);
            // destructor
            ~C_Rule(void);
        
            // type info
            DECLARE_INTERNAL_TYPE_INFO();
        
        
            /// Choice variants.
            enum E_Choice {
                e_not_set = 0,  ///< No variant selected
                e_Rule,
                e_RuleToMany
            };
            /// Maximum+1 value of the choice variant enumerator.
            enum E_ChoiceStopper {
                e_MaxChoice = 3 ///< == e_RuleToMany+1
            };
        
            /// Reset the whole object
            void Reset(void);
        
            /// Reset the selection (set it to e_not_set).
            void ResetSelection(void);
        
            /// Which variant is currently selected.
            E_Choice Which(void) const;
        
            /// Verify selection, throw exception if it differs from the expected.
            void CheckSelected(E_Choice index) const;
        
            /// Throw 'InvalidSelection' exception.
            NCBI_NORETURN void ThrowInvalidSelection(E_Choice index) const;
        
            /// Retrieve selection name (for diagnostic purposes).
            static NCBI_NS_STD::string SelectionName(E_Choice index);
        
            /// Select the requested variant if needed.
            void Select(E_Choice index, NCBI_NS_NCBI::EResetVariant reset = NCBI_NS_NCBI::eDoResetVariant);
            /// Select the requested variant if needed,
            /// allocating CObject variants from memory pool.
            void Select(E_Choice index,
                        NCBI_NS_NCBI::EResetVariant reset,
                        NCBI_NS_NCBI::CObjectMemoryPool* pool);
        
            // types
            typedef CRule TRule;
            typedef CRuleToMany TRuleToMany;
        
            // getters
            // setters
        
            // typedef CRule TRule
            bool IsRule(void) const;
            const TRule& GetRule(void) const;
            TRule& SetRule(void);
            void SetRule(TRule& value);
        
            // typedef CRuleToMany TRuleToMany
            bool IsRuleToMany(void) const;
            const TRuleToMany& GetRuleToMany(void) const;
            TRuleToMany& SetRuleToMany(void);
            void SetRuleToMany(TRuleToMany& value);
        
        
        private:
            // copy constructor and assignment operator
            C_Rule(const C_Rule& );
            C_Rule& operator=(const C_Rule& );
            // choice state
            E_Choice m_choice;
            // helper methods
            void DoSelect(E_Choice index, NCBI_NS_NCBI::CObjectMemoryPool* pool = 0);
        
            static const char* const sm_SelectionNames[];
            // data
            NCBI_NS_NCBI::CSerialObject *m_object;
        };
    
        /// Choice variants.
        enum E_Choice {
            e_not_set = 0,  ///< No variant selected
            e_BaseData,
            e_Rule
        };
        /// Maximum+1 value of the choice variant enumerator.
        enum E_ChoiceStopper {
            e_MaxChoice = 3 ///< == e_Rule+1
        };
    
        /// Reset the whole object
        void Reset(void);
    
        /// Reset the selection (set it to e_not_set).
        void ResetSelection(void);
    
        /// Which variant is currently selected.
        E_Choice Which(void) const;
    
        /// Verify selection, throw exception if it differs from the expected.
        void CheckSelected(E_Choice index) const;
    
        /// Throw 'InvalidSelection' exception.
        NCBI_NORETURN void ThrowInvalidSelection(E_Choice index) const;
    
        /// Retrieve selection name (for diagnostic purposes).
        static NCBI_NS_STD::string SelectionName(E_Choice index);
    
        /// Select the requested variant if needed.
        void Select(E_Choice index, NCBI_NS_NCBI::EResetVariant reset = NCBI_NS_NCBI::eDoResetVariant);
        /// Select the requested variant if needed,
        /// allocating CObject variants from memory pool.
        void Select(E_Choice index,
                    NCBI_NS_NCBI::EResetVariant reset,
                    NCBI_NS_NCBI::CObjectMemoryPool* pool);
    
        // types
        typedef C_BaseData TBaseData;
        typedef C_Rule TRule;
    
        // getters
        // setters
    
        // typedef C_BaseData TBaseData
        bool IsBaseData(void) const;
        const TBaseData& GetBaseData(void) const;
        TBaseData& SetBaseData(void);
        void SetBaseData(TBaseData& value);
    
        // typedef C_Rule TRule
        bool IsRule(void) const;
        const TRule& GetRule(void) const;
        TRule& SetRule(void);
        void SetRule(TRule& value);
    
    
    private:
        // copy constructor and assignment operator
        C_Data(const C_Data& );
        C_Data& operator=(const C_Data& );
        // choice state
        E_Choice m_choice;
        // helper methods
        void DoSelect(E_Choice index, NCBI_NS_NCBI::CObjectMemoryPool* pool = 0);
    
        static const char* const sm_SelectionNames[];
        // data
        NCBI_NS_NCBI::CSerialObject *m_object;
    };
    // types
    typedef C_Attlist TAttlist;
    typedef C_Data TData;
    typedef NCBI_NS_STD::string TUrlName;
    typedef NCBI_NS_STD::list< NCBI_NS_STD::string > TSubjectType;
    typedef NCBI_NS_STD::list< NCBI_NS_STD::string > TAttribute;

    // getters
    // setters

    /// mandatory
    /// typedef C_Attlist TAttlist
    ///  Check whether the Attlist data member has been assigned a value.
    bool IsSetAttlist(void) const;
    /// Check whether it is safe or not to call GetAttlist method.
    bool CanGetAttlist(void) const;
    void ResetAttlist(void);
    const TAttlist& GetAttlist(void) const;
    void SetAttlist(TAttlist& value);
    TAttlist& SetAttlist(void);

    /// mandatory
    /// typedef C_Data TData
    ///  Check whether the Data data member has been assigned a value.
    bool IsSetData(void) const;
    /// Check whether it is safe or not to call GetData method.
    bool CanGetData(void) const;
    void ResetData(void);
    const TData& GetData(void) const;
    void SetData(TData& value);
    TData& SetData(void);

    /// optional
    /// typedef NCBI_NS_STD::string TUrlName
    ///  Check whether the UrlName data member has been assigned a value.
    bool IsSetUrlName(void) const;
    /// Check whether it is safe or not to call GetUrlName method.
    bool CanGetUrlName(void) const;
    void ResetUrlName(void);
    const TUrlName& GetUrlName(void) const;
    void SetUrlName(const TUrlName& value);
    TUrlName& SetUrlName(void);

    /// Entities for special characters 
    /// internal DTD entities 
    /// optional
    /// typedef NCBI_NS_STD::list< NCBI_NS_STD::string > TSubjectType
    ///  Check whether the SubjectType data member has been assigned a value.
    bool IsSetSubjectType(void) const;
    /// Check whether it is safe or not to call GetSubjectType method.
    bool CanGetSubjectType(void) const;
    void ResetSubjectType(void);
    const TSubjectType& GetSubjectType(void) const;
    TSubjectType& SetSubjectType(void);

    /// can be one of the following; see LinkOut SubjectTypes and Attributes 
    /// at http://www.ncbi.nlm.nih.gov/entrez/linkout/doc/subjecttypes.html for a description 
    /// of these elements: 
    /////CHEMICAL INFORMATION
    ///        Biological Properties
    ///        Chemical Libraries
    ///        Imaging Agents
    ///        Metabolism
    ///        Molecular Interactions
    ///        Physical Properties
    ///        Reactions
    ///        Theoretical Properties
    ///        Toxicology
    ///        Vendors
    /////EDUCATION
    ///        conferences/meetings/workshops
    ///        glossaries/dictionaries
    ///        online tutorials/courses
    /////FUNDING SOURCES
    ///        funding sources
    /////LITERATURE
    ///        abstracts/indexes/summaries
    ///        aggregators
    ///        books
    ///        individual online article
    ///        images
    ///        libraries
    ///        patent databases
    ///        publishers/providers
    /////MEDICAL
    ///        clinical trials
    ///        consumer health
    ///        diagnostics
    ///        disease organizations
    ///        medical equipment and devices
    ///        pharmacology
    ///        treatment guidelines
    /////MOLECULAR BIOLOGY DATABASES
    ///        DNA/protein sequence
    ///        gene/protein/disease-specific
    ///        gene expression
    ///        mapping
    ///        organism-specific
    ///        population/variation
    ///        protein interactions/pathways
    ///        structure
    ///        taxonomy/phylogenetic
    /////RESEARCH MATERIALS
    ///        clones/clone libraries
    ///        culture/stock collections
    ///        laboratory equipment
    ///        oligonucleotides
    ///        other reagents
    /////RESEARCHERS
    ///        colleges/universities
    ///        companies/research institutes
    ///        directories
    ///        individuals
    ///        societies/associations
    /////TOOLS
    ///        3D structure prediction/functional modeling
    ///        primer design
    ///        protein identification/characterization
    ///        restriction mapping
    ///        sequence screening/similarity/alignment
    ///        sequence viewer
    ///        translation
    /// optional
    /// typedef NCBI_NS_STD::list< NCBI_NS_STD::string > TAttribute
    ///  Check whether the Attribute data member has been assigned a value.
    bool IsSetAttribute(void) const;
    /// Check whether it is safe or not to call GetAttribute method.
    bool CanGetAttribute(void) const;
    void ResetAttribute(void);
    const TAttribute& GetAttribute(void) const;
    TAttribute& SetAttribute(void);

    /// Reset the whole object
    virtual void Reset(void);


private:
    // Prohibit copy constructor and assignment operator
    CObjectUrl_Base(const CObjectUrl_Base&);
    CObjectUrl_Base& operator=(const CObjectUrl_Base&);

    // data
    Uint4 m_set_State[1];
    NCBI_NS_NCBI::CRef< TAttlist > m_Attlist;
    NCBI_NS_NCBI::CRef< TData > m_Data;
    NCBI_NS_STD::string m_UrlName;
    NCBI_NS_STD::list< NCBI_NS_STD::string > m_SubjectType;
    NCBI_NS_STD::list< NCBI_NS_STD::string > m_Attribute;
};






///////////////////////////////////////////////////////////
///////////////////// inline methods //////////////////////
///////////////////////////////////////////////////////////
inline
bool CObjectUrl_Base::C_Attlist::IsSetLNG(void) const
{
    return ((m_set_State[0] & 0x3) != 0);
}

inline
bool CObjectUrl_Base::C_Attlist::CanGetLNG(void) const
{
    return true;
}

inline
void CObjectUrl_Base::C_Attlist::ResetLNG(void)
{
    m_LNG = eAttlist_LNG_EN;
    m_set_State[0] &= ~0x3;
}

inline
void CObjectUrl_Base::C_Attlist::SetDefaultLNG(void)
{
    ResetLNG();
    m_set_State[0] |= 0x1;
}

inline
CObjectUrl_Base::C_Attlist::TLNG CObjectUrl_Base::C_Attlist::GetLNG(void) const
{
    return m_LNG;
}

inline
void CObjectUrl_Base::C_Attlist::SetLNG(CObjectUrl_Base::C_Attlist::TLNG value)
{
    m_LNG = value;
    m_set_State[0] |= 0x3;
}

inline
CObjectUrl_Base::C_Attlist::TLNG& CObjectUrl_Base::C_Attlist::SetLNG(void)
{
#ifdef _DEBUG
    if (!IsSetLNG()) {
        memset(&m_LNG,UnassignedByte(),sizeof(m_LNG));
    }
#endif
    m_set_State[0] |= 0x1;
    return m_LNG;
}

inline
CObjectUrl_Base::C_Data::C_BaseData::C_Rule::E_Choice CObjectUrl_Base::C_Data::C_BaseData::C_Rule::Which(void) const
{
    return m_choice;
}

inline
void CObjectUrl_Base::C_Data::C_BaseData::C_Rule::CheckSelected(E_Choice index) const
{
    if ( m_choice != index )
        ThrowInvalidSelection(index);
}

inline
void CObjectUrl_Base::C_Data::C_BaseData::C_Rule::Select(E_Choice index, NCBI_NS_NCBI::EResetVariant reset, NCBI_NS_NCBI::CObjectMemoryPool* pool)
{
    if ( reset == NCBI_NS_NCBI::eDoResetVariant || m_choice != index ) {
        if ( m_choice != e_not_set )
            ResetSelection();
        DoSelect(index, pool);
    }
}

inline
void CObjectUrl_Base::C_Data::C_BaseData::C_Rule::Select(E_Choice index, NCBI_NS_NCBI::EResetVariant reset)
{
    Select(index, reset, 0);
}

inline
bool CObjectUrl_Base::C_Data::C_BaseData::C_Rule::IsRule(void) const
{
    return m_choice == e_Rule;
}

inline
bool CObjectUrl_Base::C_Data::C_BaseData::C_Rule::IsRuleToMany(void) const
{
    return m_choice == e_RuleToMany;
}

inline
bool CObjectUrl_Base::C_Data::C_BaseData::IsSetBase(void) const
{
    return ((m_set_State[0] & 0x3) != 0);
}

inline
bool CObjectUrl_Base::C_Data::C_BaseData::CanGetBase(void) const
{
    return IsSetBase();
}

inline
const CObjectUrl_Base::C_Data::C_BaseData::TBase& CObjectUrl_Base::C_Data::C_BaseData::GetBase(void) const
{
    if (!CanGetBase()) {
        ThrowUnassigned(0);
    }
    return m_Base;
}

inline
void CObjectUrl_Base::C_Data::C_BaseData::SetBase(const CObjectUrl_Base::C_Data::C_BaseData::TBase& value)
{
    m_Base = value;
    m_set_State[0] |= 0x3;
}

inline
CObjectUrl_Base::C_Data::C_BaseData::TBase& CObjectUrl_Base::C_Data::C_BaseData::SetBase(void)
{
#ifdef _DEBUG
    if (!IsSetBase()) {
        m_Base = UnassignedString();
    }
#endif
    m_set_State[0] |= 0x1;
    return m_Base;
}

inline
bool CObjectUrl_Base::C_Data::C_BaseData::IsSetRule(void) const
{
    return m_Rule.NotEmpty();
}

inline
bool CObjectUrl_Base::C_Data::C_BaseData::CanGetRule(void) const
{
    return IsSetRule();
}

inline
const CObjectUrl_Base::C_Data::C_BaseData::TRule& CObjectUrl_Base::C_Data::C_BaseData::GetRule(void) const
{
    if (!CanGetRule()) {
        ThrowUnassigned(1);
    }
    return (*m_Rule);
}

inline
CObjectUrl_Base::C_Data::C_Rule::E_Choice CObjectUrl_Base::C_Data::C_Rule::Which(void) const
{
    return m_choice;
}

inline
void CObjectUrl_Base::C_Data::C_Rule::CheckSelected(E_Choice index) const
{
    if ( m_choice != index )
        ThrowInvalidSelection(index);
}

inline
void CObjectUrl_Base::C_Data::C_Rule::Select(E_Choice index, NCBI_NS_NCBI::EResetVariant reset, NCBI_NS_NCBI::CObjectMemoryPool* pool)
{
    if ( reset == NCBI_NS_NCBI::eDoResetVariant || m_choice != index ) {
        if ( m_choice != e_not_set )
            ResetSelection();
        DoSelect(index, pool);
    }
}

inline
void CObjectUrl_Base::C_Data::C_Rule::Select(E_Choice index, NCBI_NS_NCBI::EResetVariant reset)
{
    Select(index, reset, 0);
}

inline
bool CObjectUrl_Base::C_Data::C_Rule::IsRule(void) const
{
    return m_choice == e_Rule;
}

inline
bool CObjectUrl_Base::C_Data::C_Rule::IsRuleToMany(void) const
{
    return m_choice == e_RuleToMany;
}

inline
CObjectUrl_Base::C_Data::E_Choice CObjectUrl_Base::C_Data::Which(void) const
{
    return m_choice;
}

inline
void CObjectUrl_Base::C_Data::CheckSelected(E_Choice index) const
{
    if ( m_choice != index )
        ThrowInvalidSelection(index);
}

inline
void CObjectUrl_Base::C_Data::Select(E_Choice index, NCBI_NS_NCBI::EResetVariant reset, NCBI_NS_NCBI::CObjectMemoryPool* pool)
{
    if ( reset == NCBI_NS_NCBI::eDoResetVariant || m_choice != index ) {
        if ( m_choice != e_not_set )
            ResetSelection();
        DoSelect(index, pool);
    }
}

inline
void CObjectUrl_Base::C_Data::Select(E_Choice index, NCBI_NS_NCBI::EResetVariant reset)
{
    Select(index, reset, 0);
}

inline
bool CObjectUrl_Base::C_Data::IsBaseData(void) const
{
    return m_choice == e_BaseData;
}

inline
bool CObjectUrl_Base::C_Data::IsRule(void) const
{
    return m_choice == e_Rule;
}

inline
bool CObjectUrl_Base::IsSetAttlist(void) const
{
    return m_Attlist.NotEmpty();
}

inline
bool CObjectUrl_Base::CanGetAttlist(void) const
{
    return true;
}

inline
const CObjectUrl_Base::TAttlist& CObjectUrl_Base::GetAttlist(void) const
{
    if ( !m_Attlist ) {
        const_cast<CObjectUrl_Base*>(this)->ResetAttlist();
    }
    return (*m_Attlist);
}

inline
CObjectUrl_Base::TAttlist& CObjectUrl_Base::SetAttlist(void)
{
    if ( !m_Attlist ) {
        ResetAttlist();
    }
    return (*m_Attlist);
}

inline
bool CObjectUrl_Base::IsSetData(void) const
{
    return m_Data.NotEmpty();
}

inline
bool CObjectUrl_Base::CanGetData(void) const
{
    return true;
}

inline
const CObjectUrl_Base::TData& CObjectUrl_Base::GetData(void) const
{
    if ( !m_Data ) {
        const_cast<CObjectUrl_Base*>(this)->ResetData();
    }
    return (*m_Data);
}

inline
CObjectUrl_Base::TData& CObjectUrl_Base::SetData(void)
{
    if ( !m_Data ) {
        ResetData();
    }
    return (*m_Data);
}

inline
bool CObjectUrl_Base::IsSetUrlName(void) const
{
    return ((m_set_State[0] & 0x30) != 0);
}

inline
bool CObjectUrl_Base::CanGetUrlName(void) const
{
    return IsSetUrlName();
}

inline
const CObjectUrl_Base::TUrlName& CObjectUrl_Base::GetUrlName(void) const
{
    if (!CanGetUrlName()) {
        ThrowUnassigned(2);
    }
    return m_UrlName;
}

inline
void CObjectUrl_Base::SetUrlName(const CObjectUrl_Base::TUrlName& value)
{
    m_UrlName = value;
    m_set_State[0] |= 0x30;
}

inline
CObjectUrl_Base::TUrlName& CObjectUrl_Base::SetUrlName(void)
{
#ifdef _DEBUG
    if (!IsSetUrlName()) {
        m_UrlName = UnassignedString();
    }
#endif
    m_set_State[0] |= 0x10;
    return m_UrlName;
}

inline
bool CObjectUrl_Base::IsSetSubjectType(void) const
{
    return ((m_set_State[0] & 0xc0) != 0);
}

inline
bool CObjectUrl_Base::CanGetSubjectType(void) const
{
    return true;
}

inline
const CObjectUrl_Base::TSubjectType& CObjectUrl_Base::GetSubjectType(void) const
{
    return m_SubjectType;
}

inline
CObjectUrl_Base::TSubjectType& CObjectUrl_Base::SetSubjectType(void)
{
    m_set_State[0] |= 0x40;
    return m_SubjectType;
}

inline
bool CObjectUrl_Base::IsSetAttribute(void) const
{
    return ((m_set_State[0] & 0x300) != 0);
}

inline
bool CObjectUrl_Base::CanGetAttribute(void) const
{
    return true;
}

inline
const CObjectUrl_Base::TAttribute& CObjectUrl_Base::GetAttribute(void) const
{
    return m_Attribute;
}

inline
CObjectUrl_Base::TAttribute& CObjectUrl_Base::SetAttribute(void)
{
    m_set_State[0] |= 0x100;
    return m_Attribute;
}

///////////////////////////////////////////////////////////
////////////////// end of inline methods //////////////////
///////////////////////////////////////////////////////////





END_linkout_SCOPE // namespace linkout::


#endif // linkout__OBJTOOLS_EUTILS_LINKOUT_OBJECTURL_BASE_HPP
